/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CanvasFilterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
function nodeBondingBoxContains(outerNode, innerNode) {
  return outerNode.x <= innerNode.x && outerNode.x + outerNode.width >= innerNode.x + innerNode.width && outerNode.y <= innerNode.y && outerNode.y + outerNode.height >= innerNode.y + innerNode.height;
}
function showOnlyNodes(canvas, idsToShow) {
  const nodes = canvas.nodes.values();
  for (const node of nodes) {
    if (idsToShow === void 0 || idsToShow.has(node.id)) {
      node.nodeEl.show();
    } else {
      node.nodeEl.hide();
    }
  }
}
function showOnlyEdges(canvas, idsToShow) {
  const edges = canvas.edges.values();
  for (const edge of edges) {
    if (idsToShow === void 0 || idsToShow.has(edge.id)) {
      edge.lineGroupEl.style.display = "";
      edge.markerGroupEl.style.display = "";
    } else {
      edge.lineGroupEl.style.display = "none";
      edge.markerGroupEl.style.display = "none";
    }
  }
}
function getGroupsFor(allNodes, nonGroupNodes) {
  return allNodes.filter((x) => x.type === "group" && nonGroupNodes.some((fn) => nodeBondingBoxContains(x, fn)));
}
function getEdgesWhereBothNodesInSet(allEdges, nodeIds) {
  return allEdges.filter((edge) => nodeIds.has(edge.fromNode) && nodeIds.has(edge.toNode));
}
var CanvasFilterPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.ifActiveViewIsCanvas = (commandFn) => (checking) => {
      const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
      if ((canvasView == null ? void 0 : canvasView.getViewType()) !== "canvas") {
        if (checking) {
          return false;
        }
        return;
      }
      if (checking) {
        return true;
      }
      const canvas = canvasView.canvas;
      if (!canvas) {
        return;
      }
      ;
      const canvasData = canvas.getData();
      if (!canvasData) {
        return;
      }
      ;
      return commandFn(canvas, canvasData);
    };
    this.showConnectedNodes = (canvas, canvasData, showUpstreamNodes, showDownstreamNodes) => {
      const selection = Array.from(canvas.selection);
      if (selection.length === 0) {
        new import_obsidian.Notice("Please select at least one node");
        return;
      }
      const nodesIdsToShow = new Set(selection.map((x) => x.id).filter((x) => x));
      const edgesIdsToShow = /* @__PURE__ */ new Set();
      const addedNodes = new Set(nodesIdsToShow);
      while (addedNodes.size > 0) {
        const previousAddedNodes = new Set(addedNodes);
        addedNodes.clear();
        if (showUpstreamNodes) {
          const outgoingEdges = canvasData.edges.filter((x) => previousAddedNodes.has(x.fromNode));
          for (const edge of outgoingEdges) {
            edgesIdsToShow.add(edge.id);
            if (!nodesIdsToShow.has(edge.toNode)) {
              nodesIdsToShow.add(edge.toNode);
              addedNodes.add(edge.toNode);
            }
          }
        }
        if (showDownstreamNodes) {
          const incomingEdges = canvasData.edges.filter((x) => previousAddedNodes.has(x.toNode));
          for (const edge of incomingEdges) {
            edgesIdsToShow.add(edge.id);
            if (!nodesIdsToShow.has(edge.fromNode)) {
              nodesIdsToShow.add(edge.fromNode);
              addedNodes.add(edge.fromNode);
            }
          }
        }
      }
      const groupNodesToShow = getGroupsFor(canvasData.nodes, canvasData.nodes.filter((x) => nodesIdsToShow.has(x.id)));
      for (const node of groupNodesToShow) {
        nodesIdsToShow.add(node.id);
      }
      showOnlyNodes(canvas, nodesIdsToShow);
      showOnlyEdges(canvas, edgesIdsToShow);
    };
  }
  async onload() {
    this.addCommand({
      id: "show-all",
      name: "show ALL",
      checkCallback: this.ifActiveViewIsCanvas((canvas, canvasData) => {
        showOnlyNodes(canvas);
        showOnlyEdges(canvas);
      })
    });
    this.addCommand({
      id: "show-only-same-color",
      name: "show matching COLOR",
      checkCallback: this.ifActiveViewIsCanvas((canvas, canvasData) => {
        const selection = Array.from(canvas.selection);
        if (selection.length === 0) {
          new import_obsidian.Notice("Please select at least one node");
          return;
        }
        const colorsToShow = new Set(selection.map((x) => x.color));
        if (colorsToShow.has("")) {
          new import_obsidian.Notice("One of selected nodes has no color, so colorless nodes will be visible");
        }
        const nodes = canvasData.nodes;
        const nonGroupNodesToShow = nodes.filter((x) => {
          var _a;
          return x.type !== "group" && colorsToShow.has((_a = x.color) != null ? _a : "");
        });
        const groupNodesToShow = getGroupsFor(nodes, nonGroupNodesToShow);
        const shownNodeIds = new Set([...nonGroupNodesToShow, ...groupNodesToShow].map((x) => x.id));
        showOnlyNodes(canvas, shownNodeIds);
        const shownEdgeIds = new Set(getEdgesWhereBothNodesInSet(canvasData.edges, shownNodeIds).map((x) => x.id));
        showOnlyEdges(canvas, shownEdgeIds);
      })
    });
    this.addCommand({
      id: "show-hide",
      name: "selected HIDE",
      checkCallback: this.ifActiveViewIsCanvas((canvas, canvasData) => {
        const selection = Array.from(canvas.selection);
        if (selection.length === 0) {
          new import_obsidian.Notice("Please select at least one node");
          return;
        }
        for (const selected of selection) {
          const node = canvas.nodes.get(selected.id);
          if (node) {
            node.nodeEl.hide();
          }
          const edge = canvas.edges.get(selected.id);
          if (edge) {
            edge.lineGroupEl.style.display = "none";
            edge.markerGroupEl.style.display = "none";
          }
        }
        canvas.deselectAll();
      })
    });
    this.addCommand({
      id: "show-connected-nodes-from-to",
      name: "show with ARROWS TO/FROM",
      checkCallback: this.ifActiveViewIsCanvas((canvas, canvasData) => {
        this.showConnectedNodes(canvas, canvasData, true, true);
      })
    });
    this.addCommand({
      id: "show-connected-nodes-from",
      name: "show with ARROWS FROM",
      checkCallback: this.ifActiveViewIsCanvas((canvas, canvasData) => {
        this.showConnectedNodes(canvas, canvasData, true, false);
      })
    });
    this.addCommand({
      id: "show-connected-nodes-to",
      name: "show with ARROWS TO",
      checkCallback: this.ifActiveViewIsCanvas((canvas, canvasData) => {
        this.showConnectedNodes(canvas, canvasData, false, true);
      })
    });
    this.addCommand({
      id: "show-tags",
      name: "by TAG",
      checkCallback: this.ifActiveViewIsCanvas((canvas, canvasData) => {
        const tagsObject = this.app.metadataCache.getTags();
        const tags = Object.keys(tagsObject);
        const cardTags = canvasData.nodes.flatMap((x) => {
          if (x.type !== "text") {
            return [];
          }
          return [...x.text.matchAll(/#[^\s]+/g)].map((x2) => x2[0]);
        });
        new TagSelectionModal(this.app, [.../* @__PURE__ */ new Set([...tags, ...cardTags])], (tag) => {
          const nodesToShow = canvasData.nodes.filter((node) => {
            var _a;
            if (node.type === "file") {
              const metadata = this.app.metadataCache.getCache(node.file);
              return (_a = metadata == null ? void 0 : metadata.tags) == null ? void 0 : _a.some((x) => x.tag === tag);
            }
            if (node.type === "text") {
              return node.text.indexOf(tag) !== -1;
            }
            return false;
          });
          const groupsToShow = getGroupsFor(canvasData.nodes, nodesToShow);
          const nodeIdsToShow = new Set(nodesToShow.map((x) => x.id));
          const edgesToShow = getEdgesWhereBothNodesInSet(canvasData.edges, nodeIdsToShow);
          for (const group of groupsToShow) {
            nodeIdsToShow.add(group.id);
          }
          showOnlyNodes(canvas, nodeIdsToShow);
          showOnlyEdges(canvas, new Set(edgesToShow.map((x) => x.id)));
        }).open();
      })
    });
  }
};
var TagSelectionModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, tags, onSelect) {
    super(app);
    this.tags = tags;
    this.onSelect = onSelect;
  }
  getItems() {
    return this.tags;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.onSelect(item);
  }
};
