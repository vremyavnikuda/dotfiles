#rust #теория
В Rust много знакомых типов:

- булевый - `bool` представляет true/false
- без знаковые целочисленные - `u8` `u16` `u32` `u64` `u128` представляют только положительные числа
- знаковые целочисленные - `i8` `i16` `i32` `i64` `i128` представляют положительные и отрицательные числа
- целочисленные для размеров указателей - `usize`, `isize` для представления индексов и размеров элементов в памяти
- числа с плавающей точкой - `f32` `f64`
- кортежи - `(значение,значение,...)` представляют фиксированную последовательность из разных типов значений, размещаются на стеке
- массивы - `[значение, значение, ...]` представляют последовательность элементов одного типа, имеющий фиксированный размер известный на стадии компиляции.
- срезы (slices) - коллекция одинаковых элементов с длиной, известной во время выполнения
- строковый срез `str` ( string slice ) - текст с размером определяемым во время выполнения

Справедливое предупреждение: на других языках текст может быть сложнее, чем вы привыкли. Rust - язык системного программирования, ориентированный на решение проблем памяти, с которыми вы, возможно, не сталкивались. Мы поговорим о текстовых данных позже.

Числовые типы могут быть явно объявлены с указанным типом, если явно добавить тип у числа (пример: `13u32`, `2u8`)

```rust
fn main() {
    let x = 12; // by default this is i32
    let a = 12u8;
    let b = 4.3; // by default this is f64
    let c = 4.3f32;
    let bv = true;
    let t = (13, false);
    let sentence = "hello world!";
    println!(
        "{} {} {} {} {} {} {} {}",
        x, a, b, c, bv, t.0, t.1, sentence
    );
}

```


#### **Rust** обладает привычными типами данных:

- `**bool**` — логический тип, принимающий значения `true`, `false`
- `i8`, `i16`, `i32`, `i64`, `i128` — знаковый целочисленный тип
- `u8`, `u16`, `u32`, `u64`, `u128` — беззнаковый целочисленный тип
- `usize` , `isize` — размеры указателей, зависящие от архитектуры компьютера и используемые прим. при индексации по коллекциям  
    _Размер этого примитива — это количество байт, необходимых для ссылки на любое место в памяти.  
    Например, для 32-битной цели это 4 байта, а для 64-битной - 8 байт._
- `f32`, `f64` — числа с плавающей запятой _(нет блин тонущей запятой)_
- `char` — Unicode символ размером 4 байта.  
    _Допустимые значения_ _—_ _ASCII, Акцентированные буквы, китайские, японские и корейские символы, эмодзи и пробелы нулевой ширины_
- `(value, value, ...)` — tuple, ну или кортеж; универсальный способ объединения нескольких значений с различными типами в один составной тип
- `[value, value, ...]` — массив; коллекция для хранения одинаковых элементов с фиксированной длиной, известной во время компиляции
- слайс — коллекция одинаковых элементов, длина которых известна в runtime
- `str` — строковый слайс, текст известной длинны runtime
- `()` — unit, тип ничего _(например функция `main` по дефолту возвращает unit)_.

### Числа
```rust
let y = 92_000_000i64;
let hex_octal_bin = 0xffff_ffff + 0o777 + 0b1;

let x = i32 :: MAX;

//Функция
(-92i32).abs();
0b001100u8.count_ones();
2i32.pow(10);
```

### Числа с плавающей точкой

```rust
let y = 0.0f32; //Литерал f32
let x = 0.0; //Значение по умолчанию

let not_a_number = std::f32::NAN;
let inf = std::f32::INFINITY;

//Функция
14.5f32.ceil().sin().round().sqrt();
```

### Логический тип
```rust
let to_be = true;
let not_to_be = !to_be; //Логическое отрицание !true это false
let the_question = to_be||not_to_be; //Логическое или 
```


## Более advanced штуки, которые подробно разберем далее.

- `**String**` — динамический вектор символов, который может быть изменён во время выполнения программы _(если он предварительно был сделан изменяемым)_, целью которого является использование строки в виде переменной
- `**struct**`  — пользовательские составные типы данных, которые позволяют объединять несколько связанных значений в одном именованном блоке
- `**enum**` — тип сумма, который позволяет определять группу связанных вариантов, из которых может состоять переменная, примеры встроенных `**enum**`'ов в языке:
    - `**enum Result**` — `**enum**` имеющей два варианта: `**Ok**` и `**Err**` для обработки.
    - `**enum Option**` — `**enum**` имеющей два варианта: `**None**`,  `**Some(T)**`
- Контейнеры, структуры данных
    - `**Vec**` — вектор
    - `**HashMap**` и `**HashSet**`
- Дженерики
- `**trait**` типаж
- Лайфтаймы
- Умные указатели