#go #теория  #junior 

#### Не много сложного

Самое время вернуться к вопросу о длине и емкости среза , чтобы в контексте работы функции `append` рассмотреть внутренне устройство срезов .Что произойдет, если добавить в срез длины N  и такой же емкости элементов больше `N` ? Посмотрим на примере:

```go
baseArray := [10]int{1,2,3,4,5,6,7,8,9}
fmt.Println("Базовый массив: %v\n", baseArray)

baseSlice := baseArray[5:8]
fmt.Printf(
	"Срез, основанный на базовом массиве длиной %d и емкостью %d: %v\n",
	len(baseSlice),
	cap(baseSlice),
	baseSlice,
)

//Output:
// Базовый массив: [0 1 2 3 4 5 6 7 8 9]
// Срез, основанный на базовом массиве длиной 3 и емкостью 5 : [5 6 7]
```

И так ,мы создали массив из 10 элементов типа `int` ,а замет создали срез на его элементы 5-7 (значения элементов в пример соответствуют их индексам). Таким образом длина среза составляет 3 ,а емкость 5 .

Теперь проведем небольшую подготовительную работу .Мы знаем ,что один из компонентов среза : указатель на элемент массива который является первым элементом среза. Сохраним этот указатель в переменной `pointer` в виде строки (мы не будем его печатать, т.к во время каждого исполнения программы он будет разным ,но мы сможем использовать сохраненное значение для сравнения ):

```go
pointer := fmt.Sprintf("%p",baseSlice)
```

>Конструкция `%p` говорит, что в качестве результата должен быть возращен адрес элемента массива, на который ссылается `baseSlice`

Теперь добавим новый элемент в наш срез и посмотрим , как это повлияет на наш базовый массив:

```go
baseSlice =append(baseSclice,10)
fmt.Printf("Массив: %v\n",baseArray)
fmt.Printf("Срез длинной %d и емкостью %d: %v\n",len(baseSlice),cap(baseSlice),baseSlice)
fmt.Printf(pointer == fmt.Sprintf("%p",baseSlice))


//Output:
//Массив: [0 1 2 3 4 5 6 7 10 9]
//Срез длиной 4 и емкостью 5 : [5 6 7 10]
//true
```

Мы видим , что изменился не только наш срез , но и базовый массив, на который ссылается срез . Длина среза изменилась автоматически. А теперь повторим предыдущую операцию, но добавим столько элементов ,чтобы емкости среза не хватило:

```go
baseSlice =append(baseSlice,11,12,13)
fmt.Printf("Массив: %v\n",baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n",len(baseSlice),cap(baseSlice),baseSlice)
fmt.Println(pointer ==fmt.Sprintf("%p",baseSlice))

//Output:
//Массив: [0 1 2 3 4 5 6 7 10 9]
//Срез длиной 7 и емкостью 10: [5 6 7 10 11 12 13]
//false
```

Мы видим ,что базовый массив не изменился ,а наш срез теперь ссылается на другой массив и имеет емкость больше длины. Почему так произошло? При добавлении элементов в срез `Go` проверяет, достаточно ли емкости среза для добавления новых элементов в срез( т.е есть ли место в массиве, на которой основан срез ). Если емкости не достаточно, то создается новый срез, основанный на массиве большего объема, в который копируются все элементы из старого среза, а так же добавляются новые элементы.

Этот пример наглядно демонстрирует как устроены срезы в Go : создав раз срез на основе массива достаточной нам длины , мы можем избежать операций выделения памяти при создании нового массива и копирования элементов из одного массива в другой.