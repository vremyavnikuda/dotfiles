#go #теория 
Оператор defer позволяет выполнить определенную операцию после каких-то действий (даже если сработает panic), при этом не важно, где в реальности вызывается эта функция. Например:

```go
package main  
import "fmt"  
  
func main() {  
    defer finish()  
    fmt.Println("Program has been started")  
    fmt.Println("Program is working")  
}  
  
func finish(){  
    fmt.Println("Program has been finished")  
}
```
Здесь функция finish вызывается с оператором defer, поэтому данная функция в реальности будет вызываться в самом конце выполнения программы, несмотря на то, что ее вызов определен в начале функции main. В частности, мы получим следующий консольный вывод:

Program has been started
Program is working
Program has been finished

Если несколько функций вызываются с оператором defer, то те функции, которые вызываются раньше, будут выполняться позже всех. Например:

```go
package main  
import  "fmt"  
  
func main() {  
  
    defer finish()  
    defer fmt.Println("Program has been started")  
    fmt.Println("Program is working")  
}  
  
func finish(){  
    fmt.Println("Program has been finished")  
}
```

Консольный вывод:

Program is working
Program has been started
Program has been finished

Дополнение: команда _defer_ помещает вызов функции в стек. Поэтому они выполняются в очередности -LIFO (Last-In, First-Out)

**defer** запоминает значения переменных, переданных в функцию, на момент объявления defer, а не на момент его вызова. То есть условно

```go
a:=5  
  
defer myFunc(a) // когда вызовется myFunc - будет передано значение 5, а не 7  
  
a = 7
```
