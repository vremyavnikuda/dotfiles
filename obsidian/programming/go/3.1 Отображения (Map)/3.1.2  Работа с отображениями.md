Обратиться к элементам отображения можно с помощью обычной индексации:

```go
m := map[int]int{
	12: 2,
	1:  5,
}

fmt.Println(m[12]) // 2
```

Удаление осуществляется с помощью встроенной функции delete:

```go
m := map[int]int{
	12: 2,
	1:  5,
}

delete(m, 12) // Удаление элемента по ключу 12
fmt.Println(m) // map[1:5]
```

Все эти операции безопасны, даже если элемент в отображении отсутствует: при использовании ключа, которого нет в отображении, поиск возвращает нулевое значение соответствующего типа:

```go
m := make(map[int]int)

fmt.Println(m[12]) // 0

delete(m, 12)
fmt.Println(m) // map[]
```

В приведенном примере мы видим, что если ключ в отображении отсутствует, то при обращении к значению по ключу будет возвращено нулевое значение соответствующего типа. Особенно это критично, если согласно логике нашей программы такое нулевое значение может иметь место. Как же понять, что ключ в отображении присутствует? Мы можем воспользоваться тестом из следующего примера:

```go
m := map[int]int{
	1: 10,
}

if value, inMap := m[1]; inMap {
	fmt.Println(value) // 10
}

if value, inMap := m[2]; inMap {
	fmt.Println(value) // Условие не выполняется
}
```

Второе значение inMap - это логическое значение, показывающее, имеется ли данный элемент в отображении. Этой логической переменной часто дают имя ok.

Для перечисления всех пар "ключ-значение" в отображении мы используем циклы по диапазону, аналогичные тем, которые мы использовали для массивов и срезов. Последовательные итерации приведенного ниже цикла присваивают переменным key и value значения из очередной пары "ключ-значение" :

```go
for key, value := range mapName {
    fmt.Println(key, value)
}
```

Кроме того, Go позволяет применить к отображению функцию len, которая вернет количество пар "ключ-значение", хранящееся в отображении:

```go
m := map[int]int{
	1: 10,
	2: 20,
	3: 30,
}
fmt.Println(len(m)) // 3
```