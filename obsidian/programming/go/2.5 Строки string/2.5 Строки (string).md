#go #примерыкода #junior #теория 
### string

Строковые литералы могут быть созданы с помощью двойных кавычек "Hello World" или с помощью обратных апострофов `Hello World`. Различие между ними в том, что строки в двойных кавычках позволяют использовать особые управляющие последовательности символов. Например, \n (перенос строки) или \t (символом табуляции).

Строка представляет собой неизменяемую последовательность байтов. Из этого следует ряд выводов:

- к строке применимы операции, применимые к массивам и срезам;
- чтобы изменить строку, необходимо создать новую строку;
- мы можем итерироваться по строке как и по всякой последовательности, но итерируясь по строке, мы будем итерироваться по байтам, составляющим строку, а не по символам;
- мы можем определить в строке подстроку.

```go
func ExampleString() {  
    // Создадим строковый литерал s, значение которого "Это строка".  
    // Строка состоит из 10 символов.    var s string = "Это строка"  
  
    // Однако длина строки len(s) составит 19 байт, т.к. использованные кирилические символы  
    // занимают 2 байта, а пробел занимает 1 байт.    fmt.Printf("Длина строки: %d байт\n", len(s))  
  
    // Посмотрим как взять подстроку  
    fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:])  
  
    /*  
       Попробуем изменить что-то встроке:       s[3] = 12       Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.    */  
    // "Изменим строку", создав новую    s = s + " Новая строка"  
    fmt.Printf("%v\n", s)  
  
    // А теперь проитерируемся по этой строке  
    for _, b := range s {  
       fmt.Printf("%v ", b)  
    }    fmt.Print("\n")  
  
    // Output:  
    // Длина строки: 19 байт    // Напечатаем только второе слово в кавычках: "строка"    // Это строка Новая строка    // 1069 1090 1086 32 1089 1090 1088 1086 1082 1072 32 1053 1086 1074 1072 1103 32 1089 1090 1088 1086 1082 1072  
}
```
В заключение скажем, что строки поддерживают проверку на равенство и неравенство, а вот проверки <> со строками уже не дадут нужного нам результата, т.к. сравнивать Go будет байты, а не символы, т.е. результат для нас может быть не тот, что мы ожидаем (сравнивается не длина строк):
```go
func ExampleEqualString() {  
    fmt.Printf("Сравнение на равенство строк \"строка1\" и \"строка2\": %v\n", "строка1" == "строка2")  
    fmt.Printf("Сравнение на неравенство строк \"строка1\" и \"строка2\": %v\n", "строка1" != "строка2")  
  
    fmt.Printf("\"Строка1\" > \"Строка2\": %v", "Строка1" > "Строка2")  
  
    // Output:  
    // Сравнение на равенство строк "строка1" и "строка2": false    // Сравнение на неравенство строк "строка1" и "строка2": true    // "Строка1" > "Строка2": false}
```