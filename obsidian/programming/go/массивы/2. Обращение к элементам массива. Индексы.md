#go #теория #junior 
Для обращения к элементам массива применяются индексы - номера элементов. При этом нумерация элементов массива назначается с нуля , то есть первый элемент будет иметь индекс 0. Индекс указывается в квадратных скобках. По индексу можно получить значение элемента, либо изменить его :
```go
package main 
import(
	"fmt"
)

func main(){
	var numbers [5]int = [5]int {1,2,3,4,5}

	fmt.Println(numbers[0]) //1
	fmt.Println(numbers[4]) //5

	numbers[0] = 87
	fmt.Println(numbers[0]) //87
}
```

Однако в большинстве случаев нам необходимо обратиться ко всем элементам массива и выполнить с ними определенную работу .Мы можем сделать это с помощью цикла:

```go
a:=[5]int {1,2,3,4,5}
fmt.Println(a) //[1,2,3,4,5]

for i:=0;i<len(a); i++{
	fmt.Println(a[i])
	//1
	//2
	//3
	//4
	//5
}
```

Обратим внимание  ,что определяя условие продолжения выполнения цикла мы использовали встроенную функцию `len()` , возвращающую длину массива. Поскольку индексация элементов массива начинается с 0 , то последний элемент массива ,а будет иметь индекс `len(a)-1`.

При итерации по массиву мы можем использовать ключевое слово `range` ,тогда цикл будет иметь следующий вид:

```go
a := [5]int{1,2,3,4,5}
fmt.Println(a) //[1,2,3,4,5]

for  idx,elm := range a {
	fmt.Println("Элемент с индексом %d\n",idx,elem)
	//Элемент с индексом 0: 1
	//Элемент с индексом 1: 2
	//Элемент с индексом 2: 3
	//Элемент с индексом 3: 4
	//Элемент с индексом 4: 5
}
```

`range` возвращает 2 объекта : индекс элемента в массиве и копию значения этого элемента. Любой из этих объектов должен быть опущен, если мы планируем использовать его , для этого вместо имени переменной мы можем указать символ `_` . Кроме того , если мы хотим использовать только индекс элемента, мы можем вообще не использовать второе возвращаемое значение :

```go
a := [5]int {1,2,3,4,5}

for idx := range a {
	fmt.Println(a[idx])
}

for idx,_ := range a {
	//В этом случае следует использовать приведенный выше варинат,
	//хотя технически эти варианты работают одинакого
	fmt.Println(a[idx])
}

for _,elem :=range a {
	fmt.Println(elem)
}
```

Необходимо запомнить , что в качестве второго значения `range` возвращает копию элемента массива, это может быть важно , если в цикле мы хотим изменить массив . В этом случае мы должны обращаться к элементам массива по индексу:

```go
a := [5]int{1,2,3,4,5}
fmt.Println(a) //[1,2,3,4,5]

for _,elem :=range a {
	elem = 100
	fmt.Println(elem)
	//100
	//100
	//100
	//100
	//100
}

fmt.Println(a) //[1,2,3,4,5]

for idx :=range a {
	a[idx]= 100
	fmt.Println(a[idx])
	//100
	//100
	//100
	//100
	//100
}
fmt.Println(a) //[100,100,100,100,100]
```