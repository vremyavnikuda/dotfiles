 #cpp 
# Тема №4 Многомерные массивы - матрицы.

### Вопрос 1 : Запишите последовательность действий для исключения из многомерного массива элемента с заданным значением.

Исключение элемента с заданным значением из многомерного массива в C++ требует нескольких шагов, так как непосредственно
удалить элемент нельзя — вместо этого обычно используется маркировка элемента как `“недействительного”` или перестройка
массива. Вот последовательность действий:

1. Определите значение, которое нужно исключить.
2. Пройдитесь по всем элементам многомерного массива с помощью вложенных циклов.
3. Когда вы находите элемент с заданным значением, вы можете:

-
    - Маркировать его как `“недействительный”`, например, установив специальное значение, которое не будет
      использоваться в дальнейших операциях (например, `INT_MIN` для целочисленных массивов).
-
    - Сдвинуть оставшиеся элементы для заполнения пробела, если порядок элементов не важен.
-
    - Создать новый массив без элемента с заданным значением, если порядок элементов важен.

```cpp
#include <iostream>
#include <climits> // Для INT_MIN

const int INVALID = INT_MIN; // Маркер для недействительных элементов

void excludeValue(int** array, int rows, int cols, int valueToExclude) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (array[i][j] == valueToExclude) {
                array[i][j] = INVALID; // Маркируем элемент как недействительный
            }
        }
    }
}

int main() {
    const int rows = 3;
    const int cols = 3;
    int valueToExclude = 5;
    int array[rows][cols] = {{5, 2, 3}, {4, 5, 6}, {7, 8, 9}};

    // Преобразуем массив в массив указателей для передачи в функцию
    int* ptrArray[rows];
    for (int i = 0; i < rows; ++i) {
        ptrArray[i] = array[i];
    }

    excludeValue(ptrArray, rows, cols, valueToExclude);

    // Выводим массив после исключения значения
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (array[i][j] == INVALID) {
                std::cout << "X "; // Выводим X для недействительных элементов
            } else {
                std::cout << array[i][j] << ' ';
            }
        }
        std::cout << std::endl;
    }

    return 0;
}
```

`excludeValue` ищет и маркирует все элементы с заданным значением 5 как недействительные. В основной программе выводится
измененный массив, где все исключенные элементы отмечены символом X. Если вам нужно физически удалить элементы из
массива, потребуется создать новый массив и скопировать в него только действительные элементы.
___

### Вопрос 2 : Запишите последовательность операторов для добавления элемента в необходимую позицию в многомерном массиве.

Добавление элемента в определенную позицию многомерного массива в C++ непосредственно невозможно, так как размеры
статических массивов фиксированы после их объявления. Однако, работая с динамическим массивом или контейнером
типа `std::vector`, можно изменять его содержимое. Для статических массивов можно только изменить значение существующего
элемента.

Если задача предполагает использование динамического массива или std::vector векторов, то можно добавить элемент
следующим образом:

- Определи позицию, куда нужно добавить элемент.
- Создай новый многомерный динамический массив или вектор векторов с размером на один элемент больше в нужном измерении.
- Скопируй элементы из старого массива в новый, оставляя место для нового элемента.
- Вставь новый элемент в освободившееся место.
- Удали старый массив, если он был динамически выделен.

```cpp
#include <iostream>
#include <vector>

void insertElement(std::vector<std::vector<int>>& matrix, int row, int col, int value) {
    if (row >= matrix.size() || col >= matrix[row].size()) {
        std::cerr << "Позиция за пределами массива." << std::endl;
        return;
    }

    // Вставляем элемент в указанную позицию
    matrix[row].insert(matrix[row].begin() + col, value);
}

int main() {
    std::vector<std::vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int value = 99; // Значение для добавления
    int row = 1;    // Ряд для добавления
    int col = 1;    // Колонка для добавления

    insertElement(matrix, row, col, value);

    // Выводим матрицу после вставки
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }

    return 0;
} 
```

`insertElement` добавляет элемент `99` в позицию `(1, 1)` двумерного вектора `matrix`. После добавления элемента, все
элементы в ряду сдвигаются на одну позицию вправо, начиная с позиции вставки. Обрати внимание, что векторы в C++
обеспечивают гибкость для таких операций, в отличие от статических массивов.
___

### Вопрос 3 : Каким образом двумерные (многомерные) массивы размещаются в памяти компьютера?

Двумерные (многомерные) массивы в C++ размещаются в памяти компьютера последовательно, один за другим. Это означает, что
элементы массива хранятся в памяти так, как если бы это был одномерный массив. Для двумерного массива, первый индекс
обычно отвечает за строку, а второй — за столбец. При этом элементы одной строки располагаются в памяти последовательно.

Например, если у нас есть двумерный массив `int arr[2][3]`, то он будет представлен в памяти следующим образом:

```cpp
arr[0][0], arr[0][1], arr[0][2], arr[1][0], arr[1][1], arr[1][2]
```

Таким образом, если мы хотим обратиться к элементу `arr[1][2]`, компилятор вычислит его адрес, используя размер типа
данных (`sizeof(int)` в данном случае), количество элементов в строке и индексы. В памяти это будет выглядеть как
обращение к элементу одномерного массива по смещению, рассчитанному на основе этих параметров.

Для многомерных массивов логика аналогична, но с дополнительными измерениями. Каждое новое измерение добавляет уровень
вложенности в расчет адреса элемента. Все элементы многомерного массива также хранятся в памяти последовательно.
___

### Вопрос 4 : Как определить объем памяти, отводимой под многомерный массив?

Объем памяти, отводимый под многомерный массив в C++, можно определить, умножив размер всех измерений массива на размер
типа элемента массива. Для статически выделенного многомерного массива формула для расчета объема памяти выглядит
следующим образом:

$$\text{Объем памяти} = \text{sizeof(тип элемента)} \times n_1 \times n_2 \times \ldots \times n_k$$


где `n_1`, `n_2`, `...`, `n_k` — размеры измерений массива, а `k` — количество измерений.

Например, если у вас есть двумерный массив `int arr[10][20]`, то объем памяти, который он занимает, будет:

$$\text{Объем памяти} = \text{sizeof(int)} \times 10 \times 20$$


В этом случае, если `sizeof(int)` равен `4 байтам`, то массив `arr` займет:

$$4 \text{ байта} \times 10 \times 20 = 800 \text{ байта}$$


Для динамически выделенных многомерных массивов, таких как массивы указателей, объем памяти будет включать как память, выделенную для хранения указателей, так и память, выделенную для хранения самих элементов массива. В таком случае расчет будет сложнее и должен учитывать размеры всех указателей и размеры всех массивов, на которые они указывают.
___
### Вопрос 5 : Почему первый элемент в матрице имеет индексы 0, 0, а не 1,1? Дайте графическое представление матрицы в памяти.
В C++ индексация массивов начинается с нуля

Это означает, что первый элемент любого массива (включая многомерные) имеет индекс `0`. Такой подход к индексации упрощает вычисление адреса элемента в памяти, так как адрес можно вычислить как начальный адрес массива плюс размер элемента, умноженный на индекс.

$$\begin{bmatrix}
a_{0,0} & a_{0,1} & \cdots & a_{0,n} \\
a_{1,0} & a_{1,1} & \cdots & a_{1,n} \\
\vdots  & \vdots  & \ddots & \vdots  \\
a_{m,0} & a_{m,1} & \cdots & a_{m,n} \\
\end{bmatrix}
$$

Здесь `arr[m][n]` представляет собой двумерный массив с `m+1` строками и `n+1` столбцами. В памяти элементы каждой строки располагаются последовательно, один за другим, а строки следуют друг за другом без промежутков. Это упрощает доступ к элементам массива и их адресацию. Поэтому индексация начинается с нуля, чтобы первый элемент массива имел смещение 0 от начального адреса массива.
___
### Вопрос 6 : Каким образом можно оперировать с двумерным массивом как с одномерным, используя одну пару квадратных скобок?
Чтобы оперировать с двумерным массивом как с одномерным в C++, можно использовать указатель на первый элемент массива. Так как элементы двумерного массива хранятся в памяти последовательно, можно обращаться к элементам массива, используя арифметику указателей.
```cpp
#include <iostream>

int main() {
    const int rows = 4;
    const int cols = 3;
    int twoDimArray[rows][cols] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};

    // Получаем указатель на первый элемент двумерного массива
    int* oneDimArray = &twoDimArray[0][0];

    // Теперь мы можем обращаться к элементам двумерного массива
    // используя одну пару квадратных скобок
    for (int i = 0; i < rows * cols; ++i) {
        std::cout << oneDimArray[i] << ' ';
    }

    return 0;
}
```
`oneDimArray` является указателем на первый элемент двумерного массива `twoDimArray`. Мы можем обращаться к элементам двумерного массива, как если бы это был одномерный массив, используя одну пару квадратных скобок и индекс, который вычисляется как row * кол-во_столбцов + col.

Обрати внимание, что такой подход работает только для статических массивов, где элементы действительно хранятся последовательно в памяти. Для динамических массивов или массивов массивов `(std::vector<std::vector<int>>)` этот метод не подходит.
___
### Вопрос 7 : Сколько операций сравнения необходимо выполнить, чтобы найти индекс максимального элемента в массиве из N чисел?
Чтобы найти индекс максимального элемента в массиве из `( N )` чисел, в худшем случае потребуется `( N-1 )` операций сравнения. Это связано с тем, что каждый новый элемент массива нужно сравнить с текущим максимальным значением, которое обновляется при нахождении более большого элемента.
>Выражение ( N-1 ) обозначает количество элементов в массиве минус один. Это число используется для определения количества операций сравнения, необходимых для нахождения максимального элемента в массиве из ( N ) чисел. Поскольку первый элемент считается начальным максимумом, каждый из оставшихся ( N-1 ) элементов должен быть сравнен с текущим максимальным значением, чтобы определить, является ли он новым максимумом. Таким образом, ( N-1 ) является общим количеством таких сравнений.

Вот как это работает:

- Предположим, что первый элемент массива является максимальным.
- Сравниваем этот элемент со вторым элементом.
- Если второй элемент больше, он становится новым максимальным.
- Продолжаем процесс для каждого следующего элемента массива до конца.

Каждое сравнение может потенциально изменить текущее максимальное значение, и поскольку первый элемент уже учтен, сравнения начинаются со второго элемента и продолжаются до последнего, что составляет `( N-1 )` сравнений.

___
### Вопрос 8 : Какими тремя способами можно получить из функции значение максимального элемента?
Чтобы получить из функции значение максимального элемента массива в C++, можно использовать несколько подходов.

1. Возврат значения напрямую: Функция может пройти по массиву, найти максимальный элемент и вернуть его значение.
```cpp
int findMax(const int* array, int size) {
    int max = array[0];
    for (int i = 1; i < size; ++i) {
        if (array[i] > max) {
            max = array[i];
        }
    }
    return max;
}
```
2. Использование ссылки или указателя для возврата индекса: Функция может возвращать индекс максимального элемента через параметр-ссылку или параметр-указатель.
```cpp
void findMaxIndex(const int* array, int size, int& maxIndex) {
    maxIndex = 0;
    for (int i = 1; i < size; ++i) {
        if (array[i] > array[maxIndex]) {
            maxIndex = i;
        }
    }
}
```
3. Использование стандартной библиотеки: Можно использовать функции стандартной библиотеки, такие как `std::max_element`, которая возвращает итератор на максимальный элемент.
```cpp
#include <algorithm>

int findMaxWithSTL(const int* array, int size) {
    return *std::max_element(array, array + size);
}
```
>методы позволяют получить значение максимального элемента из функции, но используют разные способы возврата результата: напрямую, через параметр или с помощью итератора.
___
### Вопрос 9 : Если вычеркнуть из матрицы К строк, то сколько копий последней строки будет хранится в памяти?

Если из матрицы вычеркнуть `( K )` строк, то количество копий последней строки, хранящихся в памяти, будет зависеть от того, как именно организовано хранение матрицы в памяти и какие операции выполняются над ней.

В стандартной ситуации, когда матрица представлена в виде двумерного массива в C++, каждая строка хранится ровно один раз, независимо от её содержимого. Поэтому, если вычеркнуть `( K )` строк, в памяти не останется никаких копий вычеркнутых строк, включая последнюю строку. Однако, если используются специальные структуры данных или методы оптимизации памяти, которые позволяют избежать хранения повторяющихся данных, то ответ может быть другим.

В общем случае, для стандартного двумерного массива в C++:

- Перед вычеркиванием: Каждая строка, включая последнюю, хранится в памяти один раз.
- После вычеркивания ( K ) строк: Оставшиеся строки продолжают храниться в памяти по одному разу. Вычеркнутые строки освобождают занимаемую ими память (если это динамически выделенная память и была выполнена операция освобождения памяти).

Таким образом, если последняя строка не была вычеркнута, она продолжит храниться в памяти один раз.
___
### Вопрос 10 : Сколько операций присваивания нужно выполнить, чтобы поменять местами значения элементов первой и последней строки в матрице размером К$\times$К?

Для того чтобы поменять местами значения элементов первой и последней строки в матрице размером ( К $\times$ К ), вам потребуется выполнить ( К ) операций присваивания для каждого элемента строки. Так как у вас есть ( К ) элементов в каждой строке, вам нужно будет сделать ( 2 $\times$ К ) операций присваивания, чтобы поменять местами все элементы первой и последней строки.
```cpp
#include <iostream>
#include <vector>

void swapRows(std::vector<std::vector<int>>& matrix) {
    int K = matrix.size();
    // Предполагаем, что матрица не пустая и квадратная
    for (int i = 0; i < K; ++i) {
        std::swap(matrix[0][i], matrix[K-1][i]);
    }
}

int main() {
    // Пример матрицы размером К x К
    std::vector<std::vector<int>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    
    // Вызов функции для замены строк
    swapRows(matrix);
    
    // Вывод измененной матрицы
    for (const auto& row : matrix) {
        for (int val : row) {
            std::cout << val << ' ';
        }
        std::cout << '\n';
    }
    
    return 0;
}
```
`std::swap` для обмена элементами, что упрощает чтение и написание кода. Как и в предыдущем примере, каждый вызов `std::swap` считается за две операции присваивания. Если нужно учитывать каждый обмен как одну операцию, тогда количество операций будет равно `( К )`.
___