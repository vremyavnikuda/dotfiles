#теория #НГТУ #информатика #примерыкода
### Выберете все неверные утверждения

#### Динамическое распределение памяти используется когда :

1. Размер и количество используемых структур данных определяется на этапе компиляции программы
2. Типы и состав элементов используемых структур данных заранее неизвестны
3. Необходимо изменять требуемый объем памяти в соответствии с потребностями программы
4. Заранее неизвестна размерность обрабатываемых данных
5. Используются рекурсивные структуры данных

> Ответ:
> - Типы и состав элементов используемых структур данных заранее неизвестны
> - Необходимо изменять требуемый объем памяти в соответствии с потребностями программы
> - Заранее неизвестна размерность обрабатываемых данных
> - Используются рекурсивные структуры данных
---

#### Дополните определение

**\_\_** - другое имя уже существующего объекта

1. идентификатор
2. указатель
3. адресная переменная
4. переменная
5. ссылка

> Ответ: ссылка - другое имя уже существующего объекта

---

### Дополните определение

#### Для освобождения динамически выделенной памяти в языке С++ используется операция

1. free
2. clear
3. delete
4. default

> Ответа: delete

---

### Написать программу ,содержащую рекурсивныую функцию на языке Си,которой передается один ,параметр k- количество вводимых целых чисел

Ответ предоставить в виде

1. Определения рекурсивной функции с комментариями.
2. Не менее трех наборов тестовых данных для модульного тестирования

Задание:Найти наибольшее из отрицательных значений во вводимой последовательности из k-целых числе.Ответ вернуть как результат работы функции.

```cpp
#include <limits.h>
#include <stdio.h>
// Рекурсивная функция для нахождения наибольшего отрицательного значения
int findMaxNegative(int k)
{
    // Базовый случай ,если k==0 ,возвращаем минимальное значение целого числа
    if (k == 0)
    {
        return INT_MIN;
    }

    int num;
    printf("Введите число:");
    scanf("%d", &num);

    // Рекурсивный вызов функции для оставшихся чисел (k-1)
    int maxNegative = findMaxNegative(k - 1);
    // Если текущее число отрицательное и больше текущего максимального отрицательного числа
    if (num < 0 && num > maxNegative)
    {
        return num;
    }
    return maxNegative;
}

int main()
{
    int k;
    printf("Введите количество чисел: ");
    scanf("%d", &k);

    int maxNegative = findMaxNegative(k);

    if (maxNegative == INT_MIN)
    {
        printf("В последовательности нет отрицательных чисел.\n");
    }
    else
    {
        printf("Наибольшее из отрицательных чисел: %d\n", maxNegative);
    }
    return 0;
}
```

> Набор данных 1:
> Вводимые числа: 3, -1, -4, 2, -2
> Ожидаемый результат: -1

---

> Набор данных 2:
> Вводимые числа: 5, 8, 12, 7, 10
> Ожидаемый результат: В последовательности нет отрицательных чисел.

---

> Набор данных 3:
> Вводимые числа: 4, -6, -3, -8, -1
> Ожидаемый результат: -1

---

### Выберите операции ,которые неприменимы к указателю pnt:

char \*pnt[N]

1. Инкремент,декремент
2. Использование операции sizeof(указатель) для получения размера памяти,необходимого для указателя
3. Сложение указателей
4. Получение адреса указателя
5. Вычитание указателей
6. Инициализация указателей
7. Сложение(вычитание) указателя и целого числа
8. Разыменование указателя

> `Ответ`:
>
> -   Сложение указателей
> -   Вычитание указателей

---

### Дополните определение

#### Динамические переменные не имеют имени,доступ к ним осуществляется через

1. косвенную адресацию
2. элемент данных
3. указатель
4. ссылку
5. адрес

> Ответ: `указатель`

---

### Выберите все неверные утверждения

#### Переменная вида int \*pnt , в соответствии к контектным определением может быть:

1. Указателем на область памяти ,отведенную под элементы целочисленной матрицы
2. Константным указателем на переменную целого числа
3. Указателем на указатель на переменную типа int
4. Указателем на скалярную переменную типа int
5. Указателем на массив элементов целого типа

> Ответ:
>
> -   Константным указателем на переменную целого числа
> -   Указателем на указатель на переменную типа int

---

### Написать рекурсивную функцию обхода дерева и поиска значения соответствии с вариантом задания .Ответ вернуть как результат работы функции.

```cpp
struct bTree
{
    int value;
    bTree *left,*right;
};
```

Задание : В бинарном дереве определить кол-во чисел,которые являются степенями заданного числа k.

#### Ответ:

```cpp
#include <math.h>
#include <iostream>
//Структура определена в задании
struct bTree
{
    int value;
    bTree *left, *right;
};

// Функция для проверки ,является ли чисто степенью числа k
bool ifPowerOf(int num, int k)
{
    if (num < 1)
        return false;
    double logResult = log(num) / log(k);

    return floor(logResult) == logResult;
}

// Рекурсивная функция для обхода дерева и подсчета чисел , являющихся степенями числа k.
int countPowersOfK(bTree *root, int k)
{
    if (root == NULL)
        return 0;

    int count = 0;
    if (ifPowerOf(root->value, k))
    {
        count = 1;
    }

    count += countPowersOfK(root->left, k);
    count += countPowersOfK(root->right, k);

    return count;
}

int main()
{
    bTree *root = new bTree{16, NULL, NULL};
    root->left = new bTree{4, NULL, NULL};
    root->right = new bTree{2, NULL, NULL};
    root->left->left = new bTree{64, NULL, NULL};
    root->left->right = new bTree{8, NULL, NULL};

    int k = 2;
    int result = countPowersOfK(root, k);
    std::cout << "Количество чисел, являющихся степенями " << k << ": " << result << std::endl;

    // Освобождение памяти
    delete root->left->left;
    delete root->left->right;
    delete root->left;
    delete root->right;
    delete root;

    return 0;
}
```

---

### Выберите все правильные варианты ответов

#### Двоичное дерево поиска - это ориентирное дерево ,в котором:

1. Из каждой вершины выходит не менее двух ребер
2. Используя включения элемента в бинарное дерево ,можно отсортировать входную последовательность данных по выбранному ключу.
3. В каждую вершину ,включая корень,входит одно ребро
4. Из каждой вершины ,включая корень ,выходит не менее трех ребер.
5. Значение в любом узле его левого поддерева меньше ,а правого поддерева - больше значения в его родительском узле.
6. Имеется ровно одна вершина ,в которую не входит ни одного ребра - это корень дерева.

> Ответы:

    - Используя включения элемента в бинарное дерево, можно отсортировать входную последовательность данных по выбранному ключу.
    - В каждую вершину, включая корень, входит одно ребро.
    - Значение в любом узле его левого поддерева меньше, а правого поддерева — больше значения в его родительском узле.
    - Имеется ровно одна вершина, в которую не входит ни одного ребра — это корень дерева.

---

### Установите соответствие между Фрагментами программ и Способами формирования структур данных :

1. Элементы - статические переменные, связи устанавливаются программно
2. Элементы и связи формируются компилятором
3. Элементы - динамические переменные ,связи устанавливаются программно

```cpp
struct list
{
    char letter;
    struct list *next;
};
```

1. Элементы - динамические переменные, связи устанавливаются программно.

```cpp
list *plist;
plist = new struct list[N];
for(i=0;i<N;i++) plist[i]->next = plist[i+1];
plist[i]-> next = NULL;
```

2. Элементы - динамические переменные, связи устанавливаются программно.

```cpp
void ins (struct list *ptr,char ch){
    struct list *pnew = new list;
    pnew->letter = ch;
    pnew->next = NULL;
    ptr->next=pnew;
    ptr=pnew;
}
```

3. Элементы - статические переменные, связи устанавливаются программно.

```cpp
list el1={'A',NULL};
el2 = {'D',&el1},el3={'M',&el2}, *head=&el3;
```

4. Элементы и связи формируются компилятором.

```cpp
list array[N], *head = array;
for(i=0;i<N-1;i++);
array[i].next=array+i+1;
array[i].next=NULL;
```

### Выберите все верные утверждения

1. Список допускает только посредственный просмотр элементов
2. Список дает возможность для быстрого (бинарного) поиска при соответствующей упорядоченности элементов
3. Доступ к элементу массива возможен,как через имя ,так и через указатель
4. Тип и имя одинаковы для всех элементов массива
5. Массив является линейным набором элементов с самоадресацией

Ответ:

> -   Доступ к элементу массива возможен, как через имя, так и через указатель.
> -   Тип и имя одинаковы для всех элементов массива.
> -   Массив является линейным набором элементов с самоадресацией.

---

### Выберите все неверные комментарии:

```cpp
struct list
{
    int value;
    struct list *next;
};

list *head //заголовок списка
*ptr, //ссылка на текущий элемент
*pred, //ссылка на предыдущий элемент

```

1. pred->next=ptr->next;//ссылка на следующий элемент после текущего
2. ptr=ptr->next;//переход к следующему элементу
3. if(ptr->next==NULL)//проверка ,первый элемент в списке?
4. for(ptr=head;prt!=NULL;ptr=ptr->next)//просмотр списка элементов
5. ptr=head;//текущая ссылка на первый элемент
6. if(ptr!=NULL)//проверка на конец списка
7. ptr->next->next...//удаление элемента списка

> Ответ
>
> -   if(ptr->next==NULL)//проверка ,первый элемент в списке?
> -   ptr->next->next...//удаление элемента списка

---

### Дополните операторы именами функций распределения динамической памяти

Возможные варианты ответов:

1. malloc()
2. strdup()
3. realloc()
4. calloc()

```cpp
//Третье действие
for (i=0;i<M;i++){gets(str);text[]=strdup(str);if(!text[i])break;}
```

```cpp
//Второе действие
text = (char**)malloc(M,sizeof(char*));
```

```cpp
//Пятый фрагмент
head = (struct list*)calloc(1,sizeof(struct list));head->number-1;head->next=NULL;
```

```cpp
//Шестой фрагмент
qnew = (struct list*)malloc(1* sizeof(struct list));ptr = head;ptr->next = qnew;qnew->number=5;ptr=ptr->next;
```

```cpp
//Четвертое действие
...text = (char**)realloc(text.(2*M)^sizeof(char*));
```

```cpp
//Первое действие
...str = (char*)malloc(N);
```

---

### Выберите все верные утверждения

1. Сткуртуры могут содержать в качестве элементов массивы,и массивы могут состоять из структур
2. Указатель на структуру может входить в определение того же структурного типа
3. Элементы разных структур могут иметь совпадающие имена
4. Структуры могут содержать данные только одного типа
5. Доступ к элементам структуры осуществляются с помощью индекса
6. Структуры всегда предаются в функцию по ссылке

> Ответ:
>
> -   Структуры могут содержать в качестве элементов массивы, и массивы могут состоять из структур.
> -   Элементы разных структур могут иметь совпадающие имена.

---

### Установите соответствие между Структурами данных и их Особенностями

#### Возможные варианты

1. Список

-   -   Порядок элементов поддерживается логически
-   -   Операции удаления и вставка осуществляется без перемещения элементов в памяти
-   -   Структура с произвольным доступом к элементам

2. Массив

-   -   Элементы всегда располагаются в последовательных ячейках памяти
-   -   Нет ограничений на размер структуры

### Установите соответствие между фрагментами программ и действиями над циклическим циклом

-   Исключение из списка
-   Включение в начало списка
-   Включение в середину списка
-   Включение в конец списка

### Соотнесите пары

1.Исключение из списка:

```cpp
for(p=head;p->next !=head;=p->next)
    if(pnew->number == p-> next->number)
        break;
p->next=p->next->next;
```

2.Включение в начало списка:

```cpp
for(p=head;p->next !=head;p=p->next);
p->next = p->next->next;
head=head->next;
```

3.Включение в конец списка:

```cpp
for(p=head;p->next !=head;p=p->next);
p->next = pnew;
pnew->next=head;
```

4.Включение в середину списка:

```cpp
for(p=head;p->next !=head; p =p->next)
if (pnew->number == p->number)return;
p->next=pnew;pnew->next=head;
head=pnew;
```

5.Включение в начало списка:

```cpp
for(p=head;p->next! = head;p=p->next)
    if (pnew->number==p->number)
        return;
pnew->next=head;
p->next=pnew;
```

6.Включение в середину списка:

```cpp
for(p=head;p->next !=head;p=p->next)
    if(pnew->number>p->next->number)
        break;
pnew->next=p->next;
p->next=pnew;
```

---
