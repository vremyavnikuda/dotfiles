#теория #НГТУ #информатика #примерыкода 
# Тема №5 Символьные массивы - строки.

### Вопрос 1 : В чем отличие символьных и литерных констант?

- Символьные константы:
    + Представляют одиночный символ.
    + Заключены в одинарные кавычки, например, `'A'` или `'1'`.
    + Имеют тип `char`.
    + В памяти компьютера хранятся как числовые значения `ASCII кодов` символов.


- Литерные константы (или строковые литералы):
    + Представляют последовательность символов или строку.
    + Заключены в двойные кавычки, например, `"Hello, World!"`.
    + Имеют тип `char[]` или `const char*` в C++.
    + В памяти компьютера хранятся как последовательность символов с завершающим нулевым символом `\0`, который
      указывает на конец строки.

Основное отличие заключается в том, что символьные константы используются для представления одного символа, в то время
как литерные константы используются для представления строк. Это различие важно при работе с данными типа `char` и
строками в программировании.
___

### Вопрос 2 : Что такое строка? Как производится инициализация переменных и строк?

**Строка в программировании** — это последовательность символов, используемая для хранения и обработки текста

Инициализация переменных и строк в C++ может производиться несколькими способами:

- Для простых типов данных (например, `int`, `float`, `char`):

```cpp
int number = 10; // Инициализация целочисленной переменной
char symbol = 'A'; // Инициализация символьной переменной
```

- Для строк:

```cpp
//С использованием массива символов:
char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; // Инициализация с указанием каждого символа
```

```cpp
//С использованием строкового литерала:
char greeting[] = "Hello"; // Инициализация с использованием строкового литерала
```

```cpp
//класс std::string :
#include <string>
std::string message = "Hello"; // Инициализация с использованием класса std::string
```

> Важно отметить, что при инициализации массива символов последний элемент должен быть нулевым символом `\0`, который
> указывает на конец строки. В случае класса `std::string`, управление памятью и работа со строками значительно
> упрощаются
> благодаря встроенным методам и автоматическому контролю размера строки.

___

### Вопрос 3 : Какими способами можно определять строки в программе?

В C++ строки можно определять разными способами, в зависимости от контекста и требований к программе.

- С помощью массива символов:

```cpp
char str[] = "Привет";
```

- Используя указатель на символ:

```cpp
const char* str = "Привет";
```

- С помощью класса std::string из стандартной библиотеки:

```cpp
 #include <string>
std::string str = "Привет";
```

- Инициализация с помощью конструктора std::string:

```cpp
std::string str("Привет");
```

- Использование метода assign класса std::string:

```cpp
std::string str;
str.assign("Привет");
```

- Создание строки с помощью метода std::string::operator=:

```cpp
 std::string str;
str = "Привет";
```

> Класс std::string является наиболее гибким и безопасным способом работы со строками в C++, так как он автоматически
> управляет памятью и предоставляет множество удобных методов для работы со строками, таких как append, insert, find,
> replace и другие.
___

### Вопрос 4 : Какой последовательностью операторов можно перевести число в строку и наоборот?

В C++ для преобразования числа в строку и строки в число можно использовать различные методы.

### Чисто в строку

- С использованием класса `std::ostringstream` (из библиотеки `<sstream>`)

```cpp
#include <sstream>
#include <string>

int num = 123;
std::ostringstream oss;
oss << num;
std::string str = oss.str();
```

- С использованием функции `std::to_string`

```cpp
#include <string>
int num = 123;
std::string str = std::to_string(num);
```

### Строка в число

- С использованием класса `std::istringstream` (из библиотеки `<sstream>`)

```cpp
 #include <sstream>
#include <string>

std::string str = "123";
std::istringstream iss(str);
int num;
iss >> num;
```

- С использованием функции `std::stoi` или `std::stol`

```cpp
#include <string>

std::string str = "123";
int num = std::stoi(str);
```

- С использованием функции `atoi` (из библиотеки `<cstdlib>`)

```cpp
#include <cstdlib>
#include <string>

std::string str = "123";
int num = atoi(str.c_str());
```

___
### Вопрос 5: Существуют ли особенности работы с символьными массивами? Какие? Приведите примеры.
Да, при работе с символьными массивами в C++ есть несколько особенностей, которые важно учитывать:

#### Завершающий нулевой символ: Символьные массивы в C++ должны заканчиваться нулевым символом `'\0'`, который указывает на конец строки. Это позволяет функциям стандартной библиотеки определить длину строки.
```cpp
char str[] = "Привет"; // Автоматически добавляется '\0' в конец массива
```
#### Фиксированный размер: Размер символьного массива фиксирован при его объявлении, и его нельзя изменить после инициализации. Это означает, что вы должны заранее знать максимально возможную длину строки.
```cpp
char buffer[256]; // Массив фиксированного размера для строки
```
#### Необходимость управления памятью: При работе с символьными массивами программист должен самостоятельно следить за выделением и освобождением памяти, если массивы динамические.
```cpp
char* str = new char[10];
// ... использование str ...
delete[] str; // Освобождение памяти
```
#### Операции копирования и конкатенации: Для копирования и соединения строк необходимо использовать специальные функции, такие как `strcpy` и `strcat`, поскольку прямое присваивание и сложение не поддерживаются.
```cpp
char src[] = "Источник";
char dest[20];
strcpy(dest, src); // Копирование строки
strcat(dest, " и приемник"); // Добавление строки в конец
```
#### Безопасность: Функции, работающие со строками в стиле C, такие как `strcpy` и `strcat`, могут привести к переполнению буфера, если не использовать их осторожно. Вместо них рекомендуется использовать их безопасные аналоги, такие как `strncpy` и `strncat`.
```cpp
char src[] = "Безопасный источник";
char dest[20];
strncpy(dest, src, sizeof(dest) - 1); // Безопасное копирование строки
dest[sizeof(dest) - 1] = '\0'; // Убедиться, что строка завершается нулевым символом
```
#### Сравнение строк: Для сравнения символьных массивов используется функция `strcmp`, которая сравнивает строки посимвольно.
```cpp
char str1[] = "Привет";
char str2[] = "Привет";
if (strcmp(str1, str2) == 0) {
    // Строки равны
}
```
Эти особенности делают работу с символьными массивами в C++ более сложной по сравнению с использованием класса `std::string`, который предоставляет более высокий уровень абстракции и управления строками. 
___
### Вопрос 6 : Перечислите три способа задания нулевых начальных значений элементам строки, запишите примеры.
В C++ существует несколько способов инициализации строк (массивов символов) нулевыми начальными значениями.
#### Инициализация при объявлении: При объявлении массива символов можно инициализировать все его элементы нулями, используя универсальную инициализацию или обычную инициализацию со скобками:
```cpp
char str2[10]{};    // Все элементы инициализируются нулями
```
#### Использование функции memset: Можно использовать функцию memset из заголовочного файла <cstring> для заполнения строки нулевыми значениями:
```cpp
#include <cstring>

char str[10];
memset(str, 0, sizeof(str)); // Заполнение всех элементов нулями
```

#### Использование цикла: Можно вручную инициализировать каждый элемент строки нулевым значением с помощью цикла:
```cpp
char str[10];
for (int i = 0; i < 10; ++i) {
    str[i] = '\0'; // Установка каждого элемента в нулевое значение
}
```
___
### Вопрос 7 : При работе со строками может ли индекс быть выражением? Приведите примеры.
Да, в C++ индекс при работе со строками может быть выражением. Это позволяет динамически вычислять позицию элемента в строке. Важно, чтобы выражение возвращало целочисленное значение, так как индекс должен быть целым числом.
#### Использование переменной в качестве индекса:
```cpp
std::string str = "Привет, мир!";
int i = 7; // Индекс для доступа к символу 'м'
char ch = str[i]; // ch будет равен 'м'
```
#### Использование арифметического выражения
```cpp
std::string str = "Привет, мир!";
int i = 4;
char ch = str[i + 2]; // Доступ к символу с индексом 6, который равен 'т'
```
#### Использование функции для вычисления индекса:
```cpp
std::string str = "Привет, мир!";
int getIndex() {
    // Возвращает индекс в зависимости от некоторых условий
    return 3;
}
char ch = str[getIndex()]; // Доступ к символу с индексом 3, который равен 'в'
```
#### Использование тернарного оператора:
```cpp
std::string str = "Привет, мир!";
int a = 2, b = 3;
char ch = str[(a > b) ? a : b]; // Использует большее значение из a и b как индекс
```
#### Использование выражения с циклом
```cpp
std::string str = "Привет, мир!";
for (int i = 0; i < str.length(); ++i) {
    char ch = str[(i * 2) % str.length()]; // Доступ к символу с индексом, вычисленным по формуле
    // ... делаем что-то с ch ...
}
```
___
### Вопрос 8 : Назовите преимущества строки над символьным массивом.

Строки, представленные с помощью класса `std::string`, имеют ряд преимуществ по сравнению с символьными массивами:

- **Динамическое управление памятью**: `std::string` автоматически управляет памятью, что устраняет необходимость в ручном выделении и освобождении памяти, как это требуется для символьных массивов.
- **Безопасность**: Использование `std::string` снижает риск ошибок, связанных с переполнением буфера, которые могут возникнуть при работе с символьными массивами.
- **Удобство использования**: Класс `std::string` предоставляет множество методов для удобной работы со строками, таких как `append`, `insert`, `find`, `replace` и другие, в то время как для символьных массивов требуются внешние функции, такие как `strcpy`, `strcat` и т.д.
- **Гибкость**: Строки `std::string` могут легко изменять свой размер, что позволяет добавлять, удалять и изменять содержимое без заботы о размере буфера.
- **Совместимость с STL**: `std::string` полностью совместим с контейнерами и алгоритмами Стандартной библиотеки шаблонов (STL), что облегчает интеграцию и использование в различных структурах данных и алгоритмах.
- **Автоматическое управление ресурсами**: Строки `std::string` поддерживают принцип RAII (`Resource Acquisition Is Initialization`), что означает, что ресурсы (в данном случае память) автоматически выделяются при создании объекта и освобождаются при его уничтожении.
- **Простота конкатенации**: Строки `std::string` можно легко соединять с помощью оператора `+`, в то время как для символьных массивов требуется использование специальных функций.
- **Стандартные операции сравнения**: Строки `std::string` можно сравнивать с помощью стандартных операторов сравнения, таких как `==`, `!=`, `<`, `>`, в то время как символьные массивы требуют использования функции `strcmp`.
___
### Вопрос 9 : Дайте два возможных варианта объявления аргумента-строки при передаче в функцию.
В C++ существует несколько способов передачи строки в функцию. Вот два распространенных варианта объявления аргумента-строки:

#### Передача строки как массива символов: Функция принимает C-строку в виде указателя на char. Обычно требуется, чтобы строка была завершена нулевым символом `'\0'`.
```cpp
void printString(const char* str) {
    std::cout << str;
}
```
Вызов функции:
```cpp
const char* myString = "Пример строки";
printString(myString);
```

#### Передача строки как объекта класса `std::string`: Функция принимает объект `std::string` по ссылке, что позволяет избежать копирования строки при передаче. Можно использовать константную ссылку, если строка не будет изменяться в функции.
```cpp
void printString(const std::string& str) {
    std::cout << str;
}
```
Вызов функции:
```cpp
std::string myString = "Пример строки";
printString(myString);
```
>Оба этих метода широко используются и выбор между ними зависит от контекста и требований программы. Передача строки как объекта ``std::string`` обычно предпочтительнее, так как это более безопасно и удобно, особенно когда требуется работа со строками в стиле C++
 
___
### Вопрос 10 : Напишите два способа определения длины строки.
Длину строки можно определить несколькими способами

#### Использование функции `strlen` для `C-строк`: Функция `strlen` из заголовочного файла `<cstring>` возвращает длину строки до первого встреченного нулевого символа `'\0'`.
```cpp
#include <cstring>

const char* cString = "Пример строки";
size_t length = strlen(cString); // length будет равен длине строки "Пример строки"
```

#### Использование метода ``length`` или ``size`` класса `std::string`: Методы `length` и `size` класса `std::string` возвращают длину строки, представленной объектом `std::string`.
```cpp
#include <string>

std::string str = "Пример строки";
size_t length = str.length(); // Или str.size(); оба варианта вернут длину строки
```
>Оба метода возвращают количество символов в строке, не включая завершающий нулевой символ для C-строк.
___

### Вопрос 11 : Как передать в функцию и вернуть из функции один элемент массива? Приведите примеры.

#### Передача элемента массива в функцию:
```cpp
#include <iostream>

// Функция для обработки одного элемента массива
void processElement(int element) {
    std::cout << "Обработанный элемент: " << element * 2 << std::endl;
}

int main() {
    int array[] = {1, 2, 3, 4, 5};
    // Передаем второй элемент массива (индекс 1)
    processElement(array[1]);
    return 0;
}
```

#### Возврат элемента массива из функции:
```cpp
#include <iostream>

// Функция для получения элемента массива
int getElement(const int* array, int index) {
    return array[index]; // Возвращаем элемент по указанному индексу
}

int main() {
    int array[] = {1, 2, 3, 4, 5};
    // Получаем и выводим третий элемент массива (индекс 2)
    std::cout << "Полученный элемент: " << getElement(array, 2) << std::endl;
    return 0;
}
```
>`processElement` принимает один элемент массива и выполняет с ним операцию, а функция `getElement` возвращает элемент массива по указанному индексу. Обрати внимание, что при передаче элемента массива в функцию он передается по значению, то есть создается его копия. Если хочешь изменить сам элемент массива, вам нужно передать его по ссылке или указателю.
___

### Вопрос 12 : Запишите прототипы основных функций работы со строками (библиотеки).
### Для работы со строками используется класс std::string, который включен в стандартную библиотеку. Вот примеры функций и методов, которые можно использовать с объектами std::string:

#### Конструкторы
```cpp
std::string(); // Создает пустую строку
std::string(const std::string& str); // Конструктор копирования
std::string(const std::string& str, size_t pos, size_t len = std::string::npos); // Подстрока
std::string(const char* s); // Конструктор от C-строки
std::string(const char* s, size_t n); // Конструктор от части C-строки
std::string(size_t n, char c); // Строка, заполненная символами
```
#### Методы
```cpp
size_t size() const; // Возвращает размер строки
size_t length() const; // Возвращает длину строки (аналогично size())
void clear(); // Очищает строку
bool empty() const; // Проверяет, пуста ли строка
char& operator; // Доступ к символу по индексу
char& at(size_t pos); // Доступ к символу по индексу с проверкой границ
std::string& operator+=(const std::string& str); // Конкатенация строк
std::string& append(const std::string& str); // Добавляет строку в конец
std::string& insert(size_t pos, const std::string& str); // Вставляет строку
std::string& erase(size_t pos = 0, size_t len = std::string::npos); // Удаляет часть строки
int compare(const std::string& str) const; // Сравнивает строки
```
#### Функции поиска и замены
```cpp
size_t find(const std::string& str, size_t pos = 0) const; // Поиск подстроки
size_t rfind(const std::string& str, size_t pos = std::string::npos) const; // Обратный поиск
size_t find_first_of(const std::string& str, size_t pos = 0) const; // Поиск первого вхождения
size_t find_last_of(const std::string& str, size_t pos = std::string::npos) const; // Поиск последнего вхождения
size_t find_first_not_of(const std::string& str, size_t pos = 0) const; // Поиск первого не входящего
size_t find_last_not_of(const std::string& str, size_t pos = std::string::npos) const; // Поиск последнего не входящего
std::string substr(size_t pos = 0, size_t len = std::string::npos) const; // Возвращает подстроку
std::string& replace(size_t pos, size_t len, const std::string& str); // Заменяет часть строки
```
#### Операторы
```cpp
std::string& operator=(const std::string& str); // Оператор присваивания
std::string& operator=(const char* s); // Присваивание C-строки
std::string& operator=(char c); // Присваивание символа
std::string operator+(const std::string& lhs, const std::string& rhs); // Конкатенация строк
```
#### Функции ввода/вывода
```cpp
friend std::istream& operator>>(std::istream& is, std::string& str); // Ввод из потока
friend std::ostream& operator<<(std::ostream& os, const std::string& str); // Вывод в поток
```

### В C++ для работы со строками в стиле C используется ряд функций из заголовочного файла <cstring>. Вот прототипы некоторых из основных функций:
```cpp
size_t strlen(const char* str); //strlen - возвращает длину строки
char* strcpy(char* dest, const char* src);//strcpy - копирует одну строку в другую
char* strncpy(char* dest, const char* src, size_t n);//strncpy - копирует заданное количество символов одной строки в другую
char* strcat(char* dest, const char* src);//strcat - добавляет одну строку к другой
char* strncat(char* dest, const char* src, size_t n);//strncat - добавляет заданное количество символов одной строки к другой
int strcmp(const char* str1, const char* str2);//strcmp - сравнивает две строки
int strncmp(const char* str1, const char* str2, size_t n);//strncmp - сравнивает заданное количество символов двух строк
char* strchr(const char* str, int c);//strchr - ищет первое вхождение символа в строке
char* strrchr(const char* str, int c);//strrchr - ищет последнее вхождение символа в строке
char* strstr(const char* haystack, const char* needle);//strstr - ищет первое вхождение подстроки в строке
size_t strcspn(const char* str1, const char* str2);//strcspn - возвращает длину начального сегмента строки, не содержащего символы из заданного набора
char* strpbrk(const char* str1, const char* str2);//strpbrk - ищет первое вхождение любого из символов из заданного набора в строке
char* strtok(char* str, const char* delimiters);//strtok - разбивает строку на токены
```