#rust 
Оператор `as` используется для приведения типов: позволяет преобразовать значение одного типа в другой. Но, [как пишет опытный Rust-разработчик](https://doc.rust-lang.org/nomicon/casts.html), использование `as` может привести к неожиданному поведению при преобразовании в меньший тип данных: если значение не помещается в целевой тип, происходит усечение без предупреждения — это приводит к появлению труднотрассируемых ошибок в больших проектах. Например, у нас есть число 288, которое мы хотим преобразовать в тип `u8` (8-битное беззнаковое целое число). Тип `u8` может хранить значения от 0 до 255. Очевидно, 288 не помещается в этот диапазон. При использовании `as` для преобразования вместо ожидаемой ошибки или предупреждения Rust выполняет усечение значения. В этом случае результат будет равен 32:

  

- 288 в двоичном виде: `100100000`.

- При преобразовании в `u8` Rust берет только 8 младших битов (справа налево): `00100000`.

- `00100000` в десятичной системе равно 32.

  

Это поведение станет полной неожиданностью для программистов, переключившихся на Rust с языков высокого уровня, где подобные преобразования всегда вызывают ошибки или предупреждения. Лучшее решение этой проблемы — использовать трейт `TryFrom` вместо `as`. Этот подход требует чуть больше кода, но это один из тех немногих случаев, когда отказ от стандартного приема действительно оправдан:

  

```rust
fn get_half_floor(number: u8) -> u8 {
    number / 2
}

fn main() {
    let number: u16 = 32;
    let result = match u8::try_from(number) {
        Ok(number) => get_half_floor(number),
        Err(error) => panic!("Couldn't convert {number} to u8: {error}"),
    };
    dbg!(result);
}
```

  

```
thread 'main' panicked at src/main.rs:9:23:

Couldn't convert 288 to u8: out of range integral type conversion attempted
```


`TryFrom` явно обрабатывает случай, когда значение не помещается в целевой тип данных.