#rust 
# Продвинутые типы данных в Rust

## String

Динамический вектор символов, который может быть изменён во время выполнения программы (если он предварительно был сделан изменяемым). Целью является использование строки в виде переменной.

```rust
fn main() {
    let mut s = String::from("Hello");
    s.push_str(", world!");
    println!("{}", s);
}
```
## Struct

Пользовательские составные типы данных, которые позволяют объединять несколько связанных значений в одном именованном блоке.

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    println!("Username: {}", user1.username);
}
```

## Enum

Тип сумма, который позволяет определять группу связанных вариантов, из которых может состоять переменная.

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::Write(String::from("Hello, world"));
    match msg {
        Message::Quit => println!("Quit"),
        Message::Move { x, y } => println!("Move to ({}, {})", x, y),
        Message::Write(text) => println!("Message: {}", text),
        Message::ChangeColor(r, g, b) => println!("Change color to ({}, {}, {})", r, g, b),
    }
}
```

### Встроенные Enums

#### Result

Enum, имеющий два варианта: `Ok` и `Err` для обработки.
```rust
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err(String::from("Cannot divide by zero"))
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(4.0, 2.0) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}
```

#### Option

Enum, имеющий два варианта: `None` и `Some(T)`.

```rust
fn get_length(s: &str) -> Option<usize> {
    if s.is_empty() {
        None
    } else {
        Some(s.len())
    }
}

fn main() {
    let text = "Hello";
    match get_length(text) {
        Some(length) => println!("Length: {}", length),
        None => println!("String is empty"),
    }
}

```

## Контейнеры, структуры данных
### Vec

Вектор

```rust
fn main() {
    let mut v: Vec<i32> = Vec::new();
    v.push(1);
    v.push(2);
    v.push(3);
    println!("{:?}", v);
}
```

### HashMap и HashSet

```rust
use std::collections::HashMap;
use std::collections::HashSet;

fn main() {
    // HashMap
    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
    println!("{:?}", scores);

    // HashSet
    let mut books = HashSet::new();
    books.insert("The Catcher in the Rye");
    books.insert("To Kill a Mockingbird");
    books.insert("1984");
    println!("{:?}", books);
}
```
## Дженерики

```rust
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list.iter() {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];
    let result = largest(&numbers);
    println!("The largest number is {}", result);
    
    let chars = vec!['y', 'm', 'a', 'q'];
    let result = largest(&chars);
    println!("The largest char is {}", result);
}
```

## Trait (Типаж)

```rust
trait Summary {
    fn summarize(&self) -> String;
}

struct Post {
    title: String,
    author: String,
    content: String,
}

impl Summary for Post {
    fn summarize(&self) -> String {
        format!("{} by {}", self.title, self.author)
    }
}

fn main() {
    let post = Post {
        title: String::from("Rust Programming"),
        author: String::from("John Doe"),
        content: String::from("Rust is a systems programming language..."),
    };
    println!("{}", post.summarize());
}
```

## Лайфтаймы

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let string2 = "xyz";
    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

  
## Умные указатели

### Box
```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

  

### Rc

```rust
use std::rc::Rc;

fn main() {
    let a = Rc::new(5);
    let b = Rc::clone(&a);
    println!("a = {}, b = {}", a, b);
}
```

### RefCell

```rust
use std::cell::RefCell;

fn main() {
    let x = RefCell::new(5);
    {
        let mut y = x.borrow_mut();
        *y += 1;
    }
    println!("x = {:?}", x.borrow());
}
```
