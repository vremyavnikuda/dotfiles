#rust 
Этот код делает следующее: он принимает срез `sheep`, фильтрует его, оставляя только `true` значения, и подсчитывает их количество, которое и возвращается как `u8`.

```rust
fn count_sheep(sheep:&[bool])-> u8 {  
    sheep.iter().filter(|&&present| present).count() as u8  
}

#[cfg(test)]  
mod test{  
    use crate::penguin_data::count_sheep;  
  
    #[test]  
    fn returns_correct_sheep_count() {  
        assert_eq!(count_sheep(&[false]), 0);  
        assert_eq!(count_sheep(&[true]), 1);  
        assert_eq!(count_sheep(&[true, false]), 1);  
    }  
}
```



* `.iter()` -> Этот метод создает итератор для последовательного доступа к элементам среза.
* `.filter(|&&present| present)` -> метод `filter()` который принимает замыкание (closure) .Замыкание принимает один аргумент `present`,который также является замыканием(поэтому есть && перед `present`").Замыкание фильтрует элементы среза,составляя только те ,которые  равны `true`
* `.count()`: После применения фильтрации с помощью `filter()`, вызывается метод `count()`, который подсчитывает количество элементов, удовлетворяющих условию (т.е., количество `true` значений).
* `as u8`: Возвращаемое значение `count()` преобразуется в `u8`, так как функция должна вернуть `u8` или другой тип данных (указать в функции)