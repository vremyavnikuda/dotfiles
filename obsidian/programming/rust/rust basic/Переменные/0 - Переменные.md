#rust 

Переменные объявляются с помощью ключевого слова **`let`** и именуются в `snake_case`, и разделяются на:

- ***изменяемые*** — компилятор разрешает записывать в переменную и читать из нее.
- ***неизменяемый*** — компилятор разрешает только чтение из переменной (**это не константы**).

>Имена переменных пишутся всегда в нотации: `snake_case`

```rust
fn main(){
	//Значение мутабельной переменной может быть изменено
	let mut mutable =12; //Mutable i32
	mutable =21 ;
	//Ощибка!!! Тип переменной не может быть изменен
	mutable = true;

	//Однако с помощью shadowing мы можем "переписать" значение переменной
	let mutable = true;
}
```

Обратите внимание, что мы можем присваивать одно и то же имя переменной несколько раз. Это называется **shadowing**, и тип может быть изменен для последующих ссылок на это имя.

```rust
fn main(){
	//rust наследует тип x 
	let x =13;
	println!("{}",x);
	x = 12;

	//можем явно указать тип 
	let x: f64 = 3.14159;
	println!("{}",x);

	/*можем объявить переменную и где-то дальше ее проинициализировать
	но так делается очень редко
	*/
	let x;
	x=0;
	println!("{}",x);

	//можем объявить изменяемый x
	let mut x =1488;
	println!("{}",x);
	//значение которого обновим позднее
	x=1337;
	println!("Теперь x : {}",x);
}
```
Когда переменной присваивается значение, Rust может вывести её тип в 99% случаях. Когда он не может вывести тип, вы можете добавить тип в объявление переменной.

Заметьте, что мы можем присвоить значение одной и той же переменной несколько раз. Это называется сокрытие переменной (`variable shadowing`), её тип может быть изменен в последующих присваиваниях.

>При присвоении значения **Rust** в 99% случаев сможет определить тип переменной. Если это не удается, вы можете добавить тип в объявление переменной.

```rust
fn main(){
	//еще пример аннотации типа
	let logical : bool = true;

	let a_float :f64 = 1.0 //Обычная аннотация
	let an_integer = 5i32; //суффиксная \поствфиксная аннотация

	//без явного указания ,будет использоваться значение по умолчанию для данного типа
	let default_float = 3.0;//f64
	let default_integer = 7; //i32

	//однако тип также может быть выведен из контекста
	let mut inferred_type = 12;//i64 выведен, из другого места в коде
	//компилятор смотрит где и как используется переменная 
	inferred_type = 4294967296i64;
}
```











